# Руководство по работе с несколькими пользователями

## Как работает изоляция данных

Бот уже поддерживает работу с несколькими пользователями одновременно. Каждый пользователь Telegram имеет уникальный `user_id`, который используется для изоляции данных.

### Автоматическая изоляция данных

1. **Резюме пользователей**:
   - Хранятся в памяти: `self.resumes[user_id]`
   - Сохраняются в файлы: `resumes/resume_{user_id}.txt`
   - Каждый пользователь видит только своё резюме

2. **Должности пользователей**:
   - Хранятся в памяти: `self.user_positions[user_id]`
   - Сохраняются в файл: `users_data.json`
   - Каждый пользователь имеет свою должность

3. **Подписки пользователей**:
   - Хранятся в памяти: `self.user_subscriptions[user_id]`
   - Сохраняются в файл: `users_data.json`
   - Каждый пользователь имеет свою подписку

4. **Отправленные вакансии**:
   - Общий список для всех пользователей (чтобы не дублировать вакансии)
   - Но вакансии отправляются лично каждому пользователю

### Как это работает

1. **При загрузке резюме**:
   ```python
   user_id = update.message.from_user.id  # Уникальный ID пользователя
   self.resumes[user_id] = resume_text     # Сохраняется отдельно для каждого
   ```

2. **При подтверждении должности**:
   ```python
   user_id = int(data.replace('confirm_position_', ''))
   position = self.user_positions[user_id]  # Получаем должность конкретного пользователя
   ```

3. **При отправке вакансий**:
   ```python
   await self.send_vacancy(vacancy, context, chat_id=user_id)  # Отправляется лично пользователю
   ```

## Структура файлов

```
hr_app/
├── resumes/
│   ├── resume_123456789.txt      # Резюме пользователя с ID 123456789
│   ├── resume_987654321.txt      # Резюме пользователя с ID 987654321
│   └── ...
├── users_data.json               # Должности и подписки всех пользователей
└── sent_vacancies.json           # Общий список отправленных вакансий
```

## Пример файла users_data.json

```json
{
  "positions": {
    "123456789": "Product Manager",
    "987654321": "iOS Developer"
  },
  "subscriptions": {
    "123456789": {
      "position": "Product Manager",
      "active": true,
      "created_at": "2024-01-15T10:30:00"
    },
    "987654321": {
      "position": "iOS Developer",
      "active": true,
      "created_at": "2024-01-15T11:00:00"
    }
  }
}
```

## Важные моменты

### ✅ Что работает автоматически:

1. **Каждый пользователь видит только свои данные**:
   - Своё резюме
   - Свою должность
   - Свои вакансии

2. **Данные сохраняются между перезапусками**:
   - Резюме в файлах `resumes/resume_{user_id}.txt`
   - Должности и подписки в `users_data.json`

3. **Несколько пользователей могут работать одновременно**:
   - Каждый получает свои вакансии
   - Данные не смешиваются

### ⚠️ Что нужно знать:

1. **Общий список отправленных вакансий**:
   - `sent_vacancies.json` общий для всех пользователей
   - Это сделано для того, чтобы не дублировать вакансии
   - Если нужно изолировать и это, можно создать `sent_vacancies_{user_id}.json`

2. **Один экземпляр бота**:
   - Все пользователи подключаются к одному боту
   - Но данные изолированы по `user_id`

3. **Проверка безопасности**:
   - В callback data передаётся `user_id`
   - Рекомендуется проверять, что `user_id` в callback совпадает с `query.from_user.id`

## Улучшение безопасности (опционально)

Если нужно добавить дополнительную проверку безопасности, можно модифицировать обработчики:

```python
async def handle_confirm_position(self, query, user_id: int, context: ContextTypes.DEFAULT_TYPE):
    # Проверяем, что user_id в callback совпадает с реальным пользователем
    if query.from_user.id != user_id:
        await query.answer("Ошибка: неверный пользователь", show_alert=True)
        return
    
    # Продолжаем обработку...
```

## Запуск бота для нескольких пользователей

### Вариант 1: Один бот для всех (текущая реализация)

**Как работает:**
- Один экземпляр бота запущен на сервере
- Все пользователи подключаются к этому боту
- Данные изолированы по `user_id`

**Запуск:**
```bash
python3 telegram_vacancy_bot.py
```

### Вариант 2: Отдельный бот для каждого пользователя (не рекомендуется)

Если действительно нужно, чтобы каждый пользователь имел свой отдельный бот:

1. **Создайте отдельного бота** через @BotFather для каждого пользователя
2. **Создайте отдельный `.env` файл** для каждого бота:
   ```
   .env.user1
   .env.user2
   .env.user3
   ```
3. **Запустите отдельный экземпляр** для каждого бота:
   ```bash
   # Терминал 1
   export $(cat .env.user1 | xargs)
   python3 telegram_vacancy_bot.py
   
   # Терминал 2
   export $(cat .env.user2 | xargs)
   python3 telegram_vacancy_bot.py
   ```

**⚠️ Не рекомендуется**, так как:
- Требует больше ресурсов
- Сложнее управлять
- Текущая реализация уже поддерживает множественных пользователей

## Проверка работы

1. **Откройте бота с двух разных аккаунтов Telegram**
2. **Загрузите разные резюме** с каждого аккаунта
3. **Проверьте, что каждый видит только своё резюме**:
   - Команда `/resume` должна показывать только своё резюме
4. **Проверьте файлы**:
   ```bash
   ls resumes/
   # Должны быть отдельные файлы для каждого пользователя
   ```

## Резюме

✅ **Текущая реализация уже поддерживает работу с несколькими пользователями**

- Каждый пользователь имеет уникальный `user_id`
- Данные изолированы по `user_id`
- Резюме сохраняются отдельно для каждого пользователя
- Вакансии отправляются лично каждому пользователю

**Ничего дополнительного делать не нужно!** Просто запустите бота, и он будет работать с несколькими пользователями одновременно.
